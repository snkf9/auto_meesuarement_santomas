"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.uWave = void 0;
const node_fetch_1 = require("node-fetch");
const modules_1 = require("./modules");
const privateSocketTokenRef = {};
// eslint-disable-next-line @typescript-eslint/naming-convention
class uWave {
    // #endregion
    constructor(options) {
        // #region modules
        this.modules = {};
        this.options = options;
        if (!process.env.UWAVE_API_BASE_URL) {
            process.env.UWAVE_API_BASE_URL = options.apiBaseUrl;
        }
        const { credentials } = options;
        if (options.authImmediately && credentials) {
            delete this.options.credentials;
            this.auth
                .login(credentials.email, credentials.password)
                .then(() => this.socket.connect())
                .catch((err) => {
                throw err;
            });
        }
    }
    get auth() {
        if (!this.modules.auth) {
            this.modules.auth = new modules_1.Auth(this, (jwt, socketToken) => {
                this.jwt = jwt;
                privateSocketTokenRef.token = socketToken;
            });
        }
        return this.modules.auth;
    }
    get socket() {
        if (!this.modules.socket) {
            this.modules.socket = new modules_1.Socket(this, privateSocketTokenRef);
        }
        return this.modules.socket;
    }
    get booth() {
        if (!this.modules.booth) {
            this.modules.booth = new modules_1.Booth(this);
        }
        return this.modules.booth;
    }
    get chat() {
        if (!this.modules.chat) {
            this.modules.chat = new modules_1.Chat(this);
        }
        return this.modules.chat;
    }
    get isAuthenticated() {
        return !!this.jwt;
    }
    // #region http
    request(method, endpoint, data) {
        const fetchOptions = { method };
        fetchOptions.headers = {};
        if (this.jwt) {
            fetchOptions.headers.Authorization = `JWT ${this.jwt}`;
        }
        if (!process.env.UWAVE_API_BASE_URL) {
            throw new Error('Env "UWAVE_API_BASE_URL" is not set.');
        }
        let url = process.env.UWAVE_API_BASE_URL + endpoint;
        if (method === 'get' && data) {
            const querystring = querystringify(data);
            if (querystring) {
                url += `?${querystring}`;
            }
        }
        else if (data) {
            fetchOptions.headers['Content-Type'] = 'application/json';
            fetchOptions.body = JSON.stringify(data);
        }
        return node_fetch_1.default(url, fetchOptions).then((res) => res.json());
    }
    get(endpoint, query) {
        return this.request('get', endpoint, query);
    }
    post(endpoint, data) {
        return this.request('post', endpoint, data);
    }
    put(endpoint, data) {
        return this.request('put', endpoint, data);
    }
    patch(endpoint, data) {
        return this.request('patch', endpoint, data);
    }
    delete(endpoint, query) {
        return this.request('delete', endpoint, query);
    }
}
exports.uWave = uWave;
const querystringify = (obj = {}, keyPrefix) => Object.entries(obj)
    .map(([key, value]) => typeof value !== 'object'
    ? [keyPrefix ? `${keyPrefix}[${key}]` : key, value]
        .map(encodeURIComponent)
        .join('=')
    : querystringify(value, key))
    .join('&');
//# sourceMappingURL=index.js.map