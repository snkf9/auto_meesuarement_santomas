"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const helpers_1 = require("../helpers");
const auth_1 = require("./auth");
const entities_1 = require("../types/entities");
class Booth {
    constructor(uw) {
        this.uw = uw;
    }
    getBooth() {
        return this.uw
            .get('/booth')
            .then((response) => {
            if (!response.data)
                return null;
            return helpers_1.parseDates(response.data, Booth.HISTORY_ENTRY_DATE_FIELDS);
        });
    }
    getHistory(media, offset, limit) {
        const queryOptions = {};
        if (media)
            queryOptions.filter = { media };
        if (offset || limit)
            queryOptions.page = { offset, limit };
        return this.uw
            .get('/booth/history', queryOptions)
            .then((response) => {
            const includedMedia = helpers_1.groupById(response.included.media);
            const includedUsers = helpers_1.groupById(response.included.user);
            const historyEntries = response.data.map((historyEntry) => {
                const newHistoryEntry = Object.assign({}, historyEntry);
                newHistoryEntry.user =
                    includedUsers[newHistoryEntry.user];
                newHistoryEntry.media.media =
                    includedMedia[newHistoryEntry.media.media];
                return helpers_1.parseDates(newHistoryEntry, [
                    ...Booth.HISTORY_ENTRY_DATE_FIELDS,
                    ...auth_1.default.USER_DATE_FIELDS.map((field) => `user.${field}`),
                ]);
            });
            const prevQueryOptions = parseQs(response.links.prev.split('?')[1]);
            const nextQueryOptions = parseQs(response.links.next.split('?')[1]);
            const pagination = Object.assign(Object.assign({}, response.meta), { included: undefined, getPrevPage: () => {
                    var _a, _b;
                    return this.getHistory(media, (_a = prevQueryOptions.page) === null || _a === void 0 ? void 0 : _a.offset, (_b = prevQueryOptions.page) === null || _b === void 0 ? void 0 : _b.limit);
                }, getCurrentPage: () => this.getHistory(media, offset, limit), getNextPage: () => {
                    var _a, _b;
                    return this.getHistory(media, (_a = nextQueryOptions.page) === null || _a === void 0 ? void 0 : _a.offset, (_b = nextQueryOptions.page) === null || _b === void 0 ? void 0 : _b.offset);
                } });
            delete pagination.included;
            return { historyEntries, pagination };
        });
    }
    getVote(historyId) {
        return this.uw
            .get(`/booth/${historyId}/vote`)
            .then((res) => res.data);
    }
    vote(historyId, direction) {
        return this.uw
            .put(`/booth/${historyId}/vote`, { direction })
            .then(() => null);
    }
    favorite(playlistID, historyID) {
        return this.uw
            .post('/booth/favorite', { playlistID, historyID })
            .then((response) => {
            const playlistItem = Object.assign(Object.assign({}, response.data[0]), { media: response.included.media[0] });
            return { item: playlistItem, playlistSize: response.meta.playlistSize };
        });
    }
    skip(remove, userID, reason) {
        return this.uw
            .post('/booth/skip', {
            userID,
            reason,
            remove,
        })
            .then(() => null);
    }
    replaceBooth(userID) {
        return this.uw
            .post('/booth/skip', {
            userID,
        })
            .then(() => null);
    }
}
exports.default = Booth;
Booth.VoteDirections = entities_1.VoteDirections;
Booth.HISTORY_ENTRY_DATE_FIELDS = [
    'playedAt',
    'media.media.createdAt',
    'media.media.updatedAt',
];
const parseQs = (querystring) => {
    const chunks = decodeURIComponent(querystring).split('&');
    const queryOptions = {};
    chunks.forEach((chunk) => {
        const [key, value] = chunk.split('=');
        const keyPath = key.split(/\[|\]/g).filter(Boolean);
        helpers_1.setPathValue(queryOptions, keyPath, value);
    });
    return queryOptions;
};
//# sourceMappingURL=booth.js.map