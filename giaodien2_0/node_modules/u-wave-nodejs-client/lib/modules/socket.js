"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const WebSocket = require("ws");
const events_1 = require("events");
const privateSocketTokenRef = {};
class Socket {
    constructor(uw, tokenRef) {
        this.uw = uw;
        this.emitter = new events_1.EventEmitter();
        privateSocketTokenRef.token = tokenRef.token;
    }
    get isConnected() {
        var _a;
        return ((_a = this.socket) === null || _a === void 0 ? void 0 : _a.readyState) === WebSocket.OPEN;
    }
    once(eventName, listener) {
        return this.emitter.on(eventName, listener);
    }
    on(eventName, listener) {
        return this.emitter.on(eventName, listener);
    }
    off(eventName, listener) {
        return this.emitter.off(eventName, listener);
    }
    connect() {
        return this.connectSocket(this.uw.options.wsConnectionString);
    }
    disconnect() {
        if (this.socket) {
            this.socket.close();
        }
    }
    emit(command, payload) {
        return this.emitter.emit(command, payload);
    }
    send(message) {
        if (!this.socket || this.socket.readyState !== WebSocket.OPEN)
            return;
        this.socket.send(JSON.stringify(message));
    }
    connectSocket(connectionString) {
        this.socket = new WebSocket(connectionString);
        this.socket.onopen = this.onSocketOpen.bind(this);
        this.socket.onclose = this.onSocketClose.bind(this);
        this.socket.onerror = this.onSocketError.bind(this);
        this.socket.onmessage = this.onSocketMessage.bind(this);
    }
    onSocketOpen( /* event: WebSocket.OpenEvent */) {
        return __awaiter(this, void 0, void 0, function* () {
            this.emit('connected');
            if (!this.socket || !this.isConnected)
                return;
            if (!privateSocketTokenRef.token && this.uw.isAuthenticated) {
                privateSocketTokenRef.token = yield this.uw.auth.getSocketToken();
            }
            if (privateSocketTokenRef.token) {
                this.socket.send(privateSocketTokenRef.token);
                // the token is expired after being validated
                delete privateSocketTokenRef.token;
            }
        });
    }
    onSocketClose(event) {
        event.target.removeAllListeners();
        event.target.terminate();
        delete this.socket;
        this.emit('disconnected');
    }
    onSocketError( /* event: WebSocket.ErrorEvent */) {
        this.emit('error');
    }
    onSocketMessage(event) {
        if (event.data === Socket.KEEP_ALIVE_MESSAGE)
            return;
        if (typeof event.data !== 'string')
            return;
        let payload;
        try {
            payload = JSON.parse(event.data);
        }
        catch (err) {
            // console.error(err);
            return;
        }
        switch (payload.command) {
            default:
                this.emit(payload.command, payload.data);
                break;
        }
    }
}
exports.default = Socket;
Socket.KEEP_ALIVE_MESSAGE = '-';
//# sourceMappingURL=socket.js.map